# 4장_빅오, 자료형

- 빅오 Big-O : 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는 데 사용되며, 알고리즘의 효율성을 분석하는 데에도 매우 유용하게 활용.







## 빅오

> 빅오 (O, Big-O) 란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법이다.



- 빅오는 점근적 실행 시간을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나다.
  - 점근적 실행 시간이란 입력값 n이 커질 때, 즉 입력값이 무한대를 향핼 때 함수의 실행 시간의 추이를 의미한다.
- 알고리즘은 궁극적으로는 컴퓨터로 구현되므로, 컴퓨터의 빠른 처리 능력을 감안하면 아무리 복잡한 알고리즘도 입력의 크기가 작으면 금방 끝나버린다.
  - 즉 관심의 대상이 되는 것은 입력의 크기가 충분히 클 때.

- 점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있다.
  - 시간 복잡도의 사전적 정의는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도를 의미하며, 계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다.
- 빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 상수항은 무시한다.



> - ***O(1)*** : 입력값이 아무리 커도 실행 시간은 일정. 최고의 알고리즘. 대표적으로 해시 테이블의 조회 및 삽입.
> - ***O(log n)*** : 실행시간이 입력값에 영향을 받기 시작. 그러나 크게 영향을 받지 않으며 안정적임. 대표적으로 이진 검색.
> - ***O(n)*** : 입력값만큼 실행 시간에 영향. 비례하므로 이러한 알고리즘을 선형 시간 알고리즘이라 함. 대표적으로 정렬되지 않은 리스트에서 최댓값 또는 최솟값.
> - ***O(n log n)*** : 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘. 적어도 모든 수에 대해 한 번 이상은 비교해야하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘도 O(n log n) 보다 빠를 수 없음. 물론 입력값이 최선인 경우, 비교를 건너뛰어 O(n)이 될 수 있으며, 팀 소트가 이런 로직.
> - ***O(n^2)*** : 버블 정렬같은 비효율적인 정렬 알고리즘.
> - ***O(2^n)*** : 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당. n^2 보다 2^n이 훨씬 더 크다.
> - ***O(n!)*** : 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제, TSP 를 브루트 포스로 풀이할 때. 가장 느린 알고리즘.



- 빅오는 공간 복잡도를 표현하는 데에도 널리 쓰임.
- 또한 알고리즘은 시간과 공간이 트레이드 오프 관계.
  - 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고,
  - 공간을 적게 차지하는 알고리즘은 실행 시간이 느림.







> 상한과 최악

- 빅오는 상한을 의미, 빅오메가는 하한을, 빅세타는 평균을 의미.
  - 그러나 학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있음.
- 주의할 점은 상한을 최악의 경우와 혼동하는 것.
  - 빅오 표기법은 적당히 정확하게 표현하는 방법일 뿐, 최악/평균적인 경우의 시간 복잡도와는 아무런 관계가 없음에 유의해야한다.





> 분할 상황 분석

- '분할 상황' 또는 '상각'이라고 표현하는,최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산.
  - 그 유용함 덕분에 최근에는 시간 복잡도를 분석할 때 매우 보편적으로 널리 사용.





> 병렬화

- GPU 처럼 각각의 코어 자체는 느리지만 훨씬 많은 코어를 사용해서 연산을 동시에 수행.
- 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 알고리즘의 우수성을 평가하는 매우 중요한 척도 중 하나이기도 함.







## 자료형

> 파이썬 자료형

#### 숫자

- 파이썬에서는 숫자 정수형으로 int만을 제공.
  - 버전 2까지 int와 long을 각각 별도로 제공했지만, PEP 237을 통해 버전 2.4부터는 int가 충분하지 않으면 자동으로 long으로 변경되는 구조가 됨.
    - 버전 3부터는 아예 int 단일형으로 통합. int는 임의 정밀도를 지원하며, 더 이상 파이썬에서 고정 정밀도 정수형은 지원하지 않게 됨.



- bool은 엄밀히 따지면 논리 자료형인데, 파이썬에서는 내부적으로 1(True)와 0(False)로 처리되는, int의 서브 클래스다.
  - int는 object의 하위 클래스이기도 하므로,
    - object > int > bool 의 구조를 가진다.





> 매핑

- 키와 자료형으로 구성된 복합 자료형.
  - 파이썬에 내장된 유일한 매핑 자료형은 딕셔너리.





> 집합

- 파이썬의 집합 자료형인 set은 중복된 값을 갖지 않는 자료형이다.
- set은 입력 순서가 유지되지 않으며, 중복된 값이 있을 경우 하나의 값만 유지한다.





> 시퀀스

- 어떤 특정 대상의 순서 있는 나열을 의미.
- 시퀀스는 불변과 가변으로 구분.
  - 불변에는 str, tuple, bytes가 해당.
  - 가변에는 list, dict가 해당.





- 여기서부터는 파이썬의 특수한 타입 구조.





> 원시 타입

- 원시 타입은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고, 그 공간을 오로지 값으로 채워넣음.
  - C는 원시 타입만을 지원
  - 자바는 원시 타입과 객체를 동시에 지원
  - 파이썬은 원시 타입을 지원하지 않음.
    - 원시 타입의 속도를 포기하는 대신 객체의 다양한 기능과 편의성을 택함.





> 객체

- 파이썬은 모든 것이 객체다.
  - 불변 객체 vs 가변 객체



#### 불변 객체

- 파이썬에서 변수를 할당하는 작업은 해당 객체에 대해 참조를 한다는 의미.
  - 값을 담고 있는 변수는 사실은 참조일 뿐.
    - id() 를 사용해서 확인할 수 있다.





#### 가변 객체

- 리스트를 변수 a, b 에 할당하고 리스트의 값을 변경해보면, a, b 모두 값이 변화함.
  - 리스트는 가변 객체이기 때문에 일어날 수 있다.



- ***is*** vs ***==***
  - ***is*** 는 id() 값을 비교하는 함수
  - ***==*** 는 값을 비교하는 연산자





#### 속도

- 파이썬의 객체 구조는 매우 편리하고 강력한 기능을 제공하지만, 객체 구조이기때문에 매우 느리다.
  - 넘파이가 빠른 이유는, 내부적으로 리스트를 C의 원시 타입으로 처리하기 때문.